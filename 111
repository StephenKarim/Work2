import os
import time
import pandas as pd
from openpyxl import load_workbook
from datetime import timedelta, datetime

# List of folder names to ignore
ignored_folders = ['folder_to_ignore_1', 'folder_to_ignore_2']  # Add folder names you want to ignore here

# Function to find the last valid date from the first column
def get_last_valid_date(file_path):
    try:
        # Attempt to open the file
        df = pd.read_excel(file_path, engine='xlrd' if file_path.endswith('.xls') else 'openpyxl')

        # Get the first column (index 0)
        first_column = df.iloc[:, 0].dropna().tolist()

        # Iterate over the column to find the last valid date
        last_valid_date = None
        for entry in first_column:
            # Try to convert the entry into a date if it's valid
            if isinstance(entry, (int, float)):  # Excel serial date is a float or int
                date_value = datetime(1899, 12, 30) + timedelta(days=int(entry))
                last_valid_date = date_value
            elif isinstance(entry, str):
                try:
                    # Try to convert string to date with dayfirst=True to handle European date format
                    date_value = pd.to_datetime(entry, dayfirst=True, errors='coerce')
                    if pd.notnull(date_value):
                        last_valid_date = date_value  # Update the last valid date
                except:
                    pass  # Skip if it can't be converted
            elif isinstance(entry, (pd.Timestamp, datetime)):
                last_valid_date = entry  # Update the last valid date

        # If we found a valid date, return it, adding 56 days
        if last_valid_date:
            new_date = last_valid_date + timedelta(days=56)
            return new_date.strftime('%m/%d/%Y')  # Return the date formatted for Excel
        else:
            return "None"  # If no valid date found

    except PermissionError:
        # File is open or locked
        print(f"File is open: {file_path}")
        return "File is open"

    except ValueError as e:
        if 'encrypted' in str(e).lower():
            # Handle encrypted files
            print(f"File is encrypted: {file_path}")
            return "File is encrypted"
        else:
            # Handle other value errors that are not related to encryption
            print(f"Error reading {file_path}: {e}")
            return "Error"

    except Exception as e:
        # Generic error handling for any other errors
        print(f"Error reading {file_path}: {e}")
        return "Error"

# Function to save the workbook with today's date
def save_with_today_date(workbook, folder_path):
    today_str = datetime.now().strftime('%Y-%m-%d')
    filename = f"{today_str} Active Follow ups.xlsx"
    full_path = os.path.join(folder_path, filename)
    workbook.save(full_path)
    print(f"Workbook saved as: {full_path}")

# Start tracking time
start_time = time.time()

# Specify the folder to search and the template to write to
search_folder = r"C:\Users\Stephen\Documents\1. Flows\Static examples"
template_path = r"C:\Users\Stephen\Documents\1. Flows\ALL NOTES\Active Follow Up Template.xlsx"  # Path to the template
save_folder = r"C:\Users\Stephen\Documents\1. Flows\ALL NOTES"  # Folder where the new file will be saved

# Open the existing template workbook
workbook = load_workbook(template_path)
sheet = workbook.active

# Start writing from the second row (to avoid overwriting the header)
start_row = 2

# Loop through the immediate directories in the specified folder
for foldername in os.listdir(search_folder):
    folder_path = os.path.join(search_folder, foldername)
    
    # Check if the folder is in the ignored folders list
    if foldername in ignored_folders:
        print(f"Skipping folder: {foldername}")
        continue  # Skip this folder
    
    # Check if it's a directory
    if os.path.isdir(folder_path):
        file_notes_found = False  # Track if any file note is found in the folder
        
        # Loop through the files in the current folder (no subfolders)
        for filename in os.listdir(folder_path):
            if 'file notes' in filename.lower() and (filename.endswith('.xls') or filename.endswith('.xlsx')):
                file_path = os.path.join(folder_path, filename)
                
                # Try to get the last valid date from the first column
                last_entry_value = get_last_valid_date(file_path)

                # Add the folder name with a hyperlink to the folder and the last entry value
                sheet.cell(row=start_row, column=1).value = foldername
                sheet.cell(row=start_row, column=1).hyperlink = folder_path
                sheet.cell(row=start_row, column=1).style = "Hyperlink"

                # Insert the last entry (which is a datetime object or text) directly into Excel
                sheet.cell(row=start_row, column=2).value = last_entry_value

                start_row += 1  # Move to the next row after writing
                file_notes_found = True  # Mark that a file note was found

        # If no file notes were found, add a "None found" entry for the folder
        if not file_notes_found:
            sheet.cell(row=start_row, column=1).value = foldername
            sheet.cell(row=start_row, column=1).hyperlink = folder_path
            sheet.cell(row=start_row, column=1).style = "Hyperlink"
            sheet.cell(row=start_row, column=2).value = "None found"
            start_row += 1  # Move to the next row after writing

# Save the workbook with today's date in the specified folder
save_with_today_date(workbook, save_folder)

# Calculate and display runtime
end_time = time.time()
total_runtime = end_time - start_time
print(f"Script completed in {total_runtime:.2f} seconds.")
